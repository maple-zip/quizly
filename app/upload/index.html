<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DOCX → Quizly ZIP</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-emerald-50 to-teal-50 min-h-screen p-6">

<div class="max-w-2xl mx-auto">
  <div class="bg-white rounded-2xl shadow-xl p-8 mb-6">
    <h1 class="text-3xl font-bold text-emerald-800 mb-2">DOCX → Quizly</h1>
    <p class="text-gray-600 mb-6">Tải lên file DOCX để chuyển đổi thành bài quiz và chỉnh sửa</p>
    
    <div class="space-y-4">
      <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4 mb-4">
        <label class="flex items-start cursor-pointer">
          <input type="checkbox" id="autoDistributeImages" checked class="mt-1 w-4 h-4 text-emerald-600 border-gray-300 rounded focus:ring-emerald-500">
          <div class="ml-3">
            <span class="text-sm font-semibold text-emerald-900">Tự động phân bố ảnh</span>
            <p class="text-xs text-emerald-700 mt-1">Nếu câu hỏi trắc nghiệm có đúng 4 ảnh, tự động gán mỗi ảnh cho A, B, C, D (bỏ qua vị trí ban đầu)</p>
          </div>
        </label>
      </div>
      
      <div class="border-2 border-dashed border-emerald-300 rounded-xl p-8 text-center hover:border-emerald-500 transition">
        <input type="file" id="docxInput" accept=".docx" class="hidden" onchange="handleFileUpload(this)">
        <label for="docxInput" class="cursor-pointer">
          <div class="text-emerald-600 mb-2">
            <svg class="w-16 h-16 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
            </svg>
          </div>
          <p class="text-lg font-semibold text-gray-700">Nhấn để chọn file DOCX</p>
          <p class="text-sm text-gray-500 mt-1">Hoặc kéo thả file vào đây</p>
        </label>
      </div>
    </div>
  </div>

  <div id="statusBox" class="hidden bg-blue-50 border-l-4 border-blue-500 p-4 rounded-lg">
    <div class="flex items-center">
      <svg class="animate-spin h-5 w-5 text-blue-600 mr-3" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      <p id="statusText" class="text-blue-800 font-medium"></p>
    </div>
  </div>
</div>

<script>
const DB_NAME = 'quizly_zip_storage';
const STORE_NAME = 'zip_files';

// Open IndexedDB
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Save ZIP to IndexedDB
async function saveZipToIndexedDB(zipBlob) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const data = {
      id: 'current_quiz',
      blob: zipBlob,
      timestamp: Date.now()
    };
    store.put(data).onsuccess = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

function showStatus(msg) {
  const box = document.getElementById('statusBox');
  const text = document.getElementById('statusText');
  text.textContent = msg;
  box.classList.remove('hidden');
}

async function handleFileUpload(input) {
  const file = input.files[0];
  if (!file) return;

  try {
    showStatus('Đang đọc file DOCX...');
    const arrayBuffer = await file.arrayBuffer();
    
    showStatus('Đang chuyển đổi sang HTML...');
    const result = await mammoth.convertToHtml({ arrayBuffer });
    const html = result.value;

    showStatus('Đang phân tích câu hỏi...');
    const autoDistribute = document.getElementById('autoDistributeImages').checked;
    const parsedData = await parseHTMLString(html, autoDistribute);

    showStatus('Đang tạo file ZIP...');
    const zip = await createQuizZip(parsedData);
    const zipBlob = await zip.generateAsync({ type: 'blob' });

    showStatus('Đang lưu vào bộ nhớ...');
    await saveZipToIndexedDB(zipBlob);

    showStatus('Hoàn tất! Đang chuyển hướng...');
    
    // Redirect to editor
    setTimeout(() => {
      const currentPath = window.location.pathname;
      const editorPath = currentPath.replace('/upload', '/editor');
      window.location.href = window.location.origin + editorPath;
    }, 500);

  } catch (err) {
    console.error(err);
    alert('Lỗi: ' + err.message);
    document.getElementById('statusBox').classList.add('hidden');
    input.value = '';
  }
}

function dataURLtoBlob(dataURL) {
  const parts = dataURL.split(',');
  const header = parts[0];
  const mime = header.match(/:(.*?);/)[1];
  const binary = atob(parts[1]);
  const u8 = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) u8[i] = binary.charCodeAt(i);
  return { blob: new Blob([u8], { type: mime }), mime };
}

function makeSafeName(base, index, ext) {
  return `${base}_${index}.${ext}`;
}

function toYAML(obj) {
  function esc(s) {
    if (s == null) return '""';
    s = String(s);
    if (s.match(/[:\n\r\-\"\']/)) {
      return '"' + s.replace(/"/g, '\\"') + '"';
    }
    return s;
  }
  let lines = [];
  
  if (obj.questions) {
    lines.push('questions:');
    obj.questions.forEach(q => {
      lines.push('- type: ' + q.type);
      if (q.question) {
        lines.push('  question:');
        lines.push('    text: ' + esc(q.question.text || ''));
        if (q.question.media) {
          if (Array.isArray(q.question.media)) {
            lines.push('    media:');
            q.question.media.forEach(m => lines.push('      - ' + esc(m)));
          } else {
            lines.push('    media: ' + esc(q.question.media));
          }
        }
      }
      if (q.type === 'multiple_choice') {
        lines.push('  choices:');
        for (const key of Object.keys(q.choices)) {
          const c = q.choices[key];
          lines.push(`    ${key}:`);
          lines.push('      text: ' + esc(c.text || ''));
          if (c.media) {
            if (Array.isArray(c.media)) {
              lines.push('      media:');
              c.media.forEach(m => lines.push('        - ' + esc(m)));
            } else {
              lines.push('      media: ' + esc(c.media));
            }
          }
        }
        lines.push('  correct: ' + (q.correct ? esc(q.correct) : '""'));
      } else if (q.type === 'true_false_group') {
        lines.push('  items:');
        for (const key of Object.keys(q.items)) {
          const it = q.items[key];
          lines.push(`    ${key}:`);
          lines.push('      text: ' + esc(it.text || ''));
          if (it.media) {
            if (Array.isArray(it.media)) {
              lines.push('      media:');
              it.media.forEach(m => lines.push('        - ' + esc(m)));
            } else {
              lines.push('      media: ' + esc(it.media));
            }
          }
          if (typeof it.correct === 'boolean') lines.push('      correct: ' + (it.correct ? 'true' : 'false'));
        }
      }
    });
  }
  return lines.join('\n');
}

async function parseHTMLString(htmlText, autoDistributeImages = true) {
  const doc = new DOMParser().parseFromString(htmlText, 'text/html');

  const imgEls = Array.from(doc.querySelectorAll('img'));
  const dataImgs = imgEls.filter(i => i.src && i.src.startsWith('data:'));
  const mediaFiles = new Map();
  let counter = 1;
  
  for (const img of dataImgs) {
    try {
      const { blob, mime } = dataURLtoBlob(img.src);
      const ext = mime.split('/')[1].split(';')[0] || 'png';
      const name = makeSafeName('media', counter++, ext);
      mediaFiles.set(name, blob);
      img.setAttribute('data-indexeddb-name', name);
      img.removeAttribute('src');
    } catch (e) {
      console.error('store image failed', e);
    }
  }

  const bodyNodes = Array.from(doc.body.childNodes);
  let mode = 'mc';
  const questions = [];
  let i = 0;
  
  while (i < bodyNodes.length) {
    const node = bodyNodes[i];
    const text = (node.textContent || '').trim();
    const lower = text.toLowerCase();
    
    if (lower.includes('đúng sai') || lower.includes('tn đúng sai') || lower.includes('câu hỏi tn')) {
      mode = 'tf';
      i++;
      continue;
    }

    const isQStart = /^\s*(câu\s*\d+|\d+\.|câu\s*\d+[:.])/i.test(text);
    
    if (isQStart) {
      const blockNodes = [node];
      let j = i + 1;
      
      while (j < bodyNodes.length) {
        const t = (bodyNodes[j].textContent || '').trim();
        if (/^(câu\s*\d+|\d+\.|câu\s*\d+[:.])/i.test(t)) break;
        if ((t.toLowerCase().includes('đúng sai') || t.toLowerCase().includes('ii.'))) break;
        if (/^\s*[ivx]+\b\s*\./i.test(t)) break;
        blockNodes.push(bodyNodes[j]);
        j++;
      }
      i = j;
      
      const blockText = blockNodes.map(n => n.textContent).join('\n').trim();

      // Helper: lấy ảnh từ một node
      function getMediaFromNode(n) {
        const names = [];
        // Node tự nó là <img>
        if (n.nodeType === 1 && n.tagName === 'IMG') {
          const name = n.getAttribute('data-indexeddb-name');
          if (name) names.push(name);
        }
        // <img> bên trong node
        if (n.querySelectorAll) {
          for (const im of Array.from(n.querySelectorAll('img'))) {
            const nm = im.getAttribute('data-indexeddb-name');
            if (nm) names.push(nm);
          }
        }
        return names;
      }

      let norm = blockText.replace(/\r/g, '').replace(/\t/g, ' ');
      norm = norm.replace(/\s*A\./g, '\nA.').replace(/\s*B\./g, '\nB.').replace(/\s*C\./g, '\nC.').replace(/\s*D\./g, '\nD.');
      const lines = norm.split('\n').map(s => s.trim()).filter(Boolean);
      
      const choiceLines = lines.filter(l => /^[A-D]\./.test(l));

      if (choiceLines.length >= 2 && mode === 'mc') {
        // Tìm node chứa lựa chọn A. đầu tiên
        let firstChoiceNodeIndex = -1;
        for (let idx = 0; idx < blockNodes.length; idx++) {
          const txt = (blockNodes[idx].textContent || '').trim();
          if (/A\./i.test(txt)) {
            firstChoiceNodeIndex = idx;
            break;
          }
        }

        // Ảnh của câu hỏi: chỉ lấy từ các node TRƯỚC lựa chọn A.
        const questionMediaNames = [];
        const endIdx = firstChoiceNodeIndex >= 0 ? firstChoiceNodeIndex : blockNodes.length;
        for (let idx = 0; idx < endIdx; idx++) {
          questionMediaNames.push(...getMediaFromNode(blockNodes[idx]));
        }

        let qtextLines = [];
        for (const l of lines) {
          if (/^[A-D]\./.test(l)) break;
          qtextLines.push(l);
        }
        const qtext = qtextLines.join(' ').replace(/^(câu\s*\d+[:.]?)/i, '').trim();
        
        // Xây dựng choices với text
        const choices = {};
        const map = {};
        for (const l of choiceLines) {
          const m = l.match(/^([A-D])\.\s*(.*)$/);
          if (m) map[m[1]] = m[2].trim();
        }
        ['A', 'B', 'C', 'D'].forEach(k => {
          choices[k] = { text: map[k] || '' };
        });

        // Gán ảnh cho từng lựa chọn
        if (firstChoiceNodeIndex >= 0) {
          let currentChoice = null;
          for (let idx = firstChoiceNodeIndex; idx < blockNodes.length; idx++) {
            const n = blockNodes[idx];
            const txt = (n.textContent || '').trim();
            const choiceMatch = txt.match(/^([A-D])\./);
            
            if (choiceMatch) {
              currentChoice = choiceMatch[1];
            } else if (currentChoice) {
              // Node này không phải lựa chọn mới → ảnh thuộc lựa chọn hiện tại
              const media = getMediaFromNode(n);
              if (media.length > 0) {
                if (!choices[currentChoice].media) choices[currentChoice].media = [];
                if (!Array.isArray(choices[currentChoice].media)) {
                  choices[currentChoice].media = [choices[currentChoice].media];
                }
                choices[currentChoice].media.push(...media);
              }
            }
          }
        }

        // Chuẩn hóa media của choices (đơn giản hóa nếu chỉ 1 ảnh)
        for (const k of ['A', 'B', 'C', 'D']) {
          if (choices[k].media && Array.isArray(choices[k].media)) {
            if (choices[k].media.length === 1) {
              choices[k].media = choices[k].media[0];
            } else if (choices[k].media.length === 0) {
              delete choices[k].media;
            }
          }
        }

        // TỰ ĐỘNG PHÂN BỐ ẢNH: nếu có đúng 4 ảnh trong câu hỏi
        if (autoDistributeImages) {
          // Gom tất cả ảnh từ question và choices
          const allMedia = [];
          
          // Ảnh từ question
          if (questionMediaNames.length > 0) {
            allMedia.push(...questionMediaNames);
          }
          
          // Ảnh từ choices
          for (const k of ['A', 'B', 'C', 'D']) {
            if (choices[k].media) {
              if (Array.isArray(choices[k].media)) {
                allMedia.push(...choices[k].media);
              } else {
                allMedia.push(choices[k].media);
              }
            }
          }

          // Nếu có đúng 4 ảnh → phân bố lại
          if (allMedia.length === 4) {
            // Xóa media khỏi question
            questionMediaNames.length = 0;
            
            // Gán mỗi ảnh cho A, B, C, D
            choices.A.media = allMedia[0];
            choices.B.media = allMedia[1];
            choices.C.media = allMedia[2];
            choices.D.media = allMedia[3];
          }
        }
        
        questions.push({
          type: 'multiple_choice',
          question: {
            text: qtext,
            media: questionMediaNames.length ? (questionMediaNames.length === 1 ? questionMediaNames[0] : questionMediaNames) : undefined
          },
          choices,
          correct: ''
        });
      } else if (mode === 'tf') {
        // Helper đã định nghĩa ở trên, dùng lại
        const getMediaFromNode = (n) => {
          const names = [];
          if (n.nodeType === 1 && n.tagName === 'IMG') {
            const name = n.getAttribute('data-indexeddb-name');
            if (name) names.push(name);
          }
          if (n.querySelectorAll) {
            for (const im of Array.from(n.querySelectorAll('img'))) {
              const nm = im.getAttribute('data-indexeddb-name');
              if (nm) names.push(nm);
            }
          }
          return names;
        };

        let combined = blockText.replace(/\r/g, '').replace(/\t/g, ' ');
        combined = combined.replace(/\s*a\)|\s*a\./gi, '\na.').replace(/\s*b\)|\s*b\./gi, '\nb.').replace(/\s*c\)|\s*c\./gi, '\nc.').replace(/\s*d\)|\s*d\./gi, '\nd.');
        const itLines = combined.split('\n').map(s => s.trim()).filter(Boolean);
        
        let header = '';
        if (!/^a\./i.test(itLines[0])) {
          header = itLines.shift();
        }

        // Tìm node chứa item a. đầu tiên
        let firstItemNodeIndex = -1;
        for (let idx = 0; idx < blockNodes.length; idx++) {
          const txt = (blockNodes[idx].textContent || '').trim();
          if (/a\./i.test(txt)) {
            firstItemNodeIndex = idx;
            break;
          }
        }

        // Ảnh của câu hỏi: chỉ lấy từ các node TRƯỚC item a.
        const questionMediaNames = [];
        const endIdx = firstItemNodeIndex >= 0 ? firstItemNodeIndex : blockNodes.length;
        for (let idx = 0; idx < endIdx; idx++) {
          questionMediaNames.push(...getMediaFromNode(blockNodes[idx]));
        }
        
        const items = {};
        for (const line of itLines) {
          const m = line.match(/^([a-d])\.\s*(.*)/i);
          if (m) items[m[1]] = { text: m[2].trim() };
        }

        // Gán ảnh cho từng item
        if (firstItemNodeIndex >= 0) {
          let currentItem = null;
          for (let idx = firstItemNodeIndex; idx < blockNodes.length; idx++) {
            const n = blockNodes[idx];
            const txt = (n.textContent || '').trim();
            const itemMatch = txt.match(/^([a-d])\./i);
            
            if (itemMatch) {
              currentItem = itemMatch[1].toLowerCase();
            } else if (currentItem) {
              // Node này không phải item mới → ảnh thuộc item hiện tại
              const media = getMediaFromNode(n);
              if (media.length > 0) {
                if (!items[currentItem].media) items[currentItem].media = [];
                if (!Array.isArray(items[currentItem].media)) {
                  items[currentItem].media = [items[currentItem].media];
                }
                items[currentItem].media.push(...media);
              }
            }
          }
        }

        // Chuẩn hóa media của items
        for (const k of ['a', 'b', 'c', 'd']) {
          if (items[k] && items[k].media && Array.isArray(items[k].media)) {
            if (items[k].media.length === 1) {
              items[k].media = items[k].media[0];
            } else if (items[k].media.length === 0) {
              delete items[k].media;
            }
          }
        }
        
        if (Object.keys(items).length > 0) {
          questions.push({
            type: 'true_false_group',
            question: {
              text: header || '',
              media: questionMediaNames.length ? (questionMediaNames.length === 1 ? questionMediaNames[0] : questionMediaNames) : undefined
            },
            items
          });
        }
      }
    } else {
      i++;
    }
  }

  return { questions, mediaFiles };
}

async function createQuizZip(data) {
  const zip = new JSZip();

  // Default config
  const config = `metadata:
  title: "Đề thi mặc định"
  subject: "Chưa phân loại"
  grade: "12"
  author: "Giáo viên"

exam:
  description: "Bài thi được tạo từ DOCX"
  duration_minutes: 45
  start_time: "2025-01-01T00:00:00"
  end_time: "2099-12-31T23:59:59"
  shuffle_questions: true
  shuffle_answers: true`;

  zip.file('config.yaml', config);

  const questionsYaml = toYAML(data);
  zip.file('questions.yaml', questionsYaml);

  // Thêm các file media vào thư mục media
  const mediaFolder = zip.folder('media');
  for (const [name, blob] of data.mediaFiles.entries()) {
    mediaFolder.file(name, blob);
  }

  return zip;
}

// Drag and drop support
document.addEventListener('DOMContentLoaded', () => {
  const dropArea = document.querySelector('.border-dashed');
  
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, preventDefaults, false);
  });

  function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
  }

  ['dragenter', 'dragover'].forEach(eventName => {
    dropArea.addEventListener(eventName, () => {
      dropArea.classList.add('border-emerald-500', 'bg-emerald-50');
    }, false);
  });

  ['dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, () => {
      dropArea.classList.remove('border-emerald-500', 'bg-emerald-50');
    }, false);
  });

  dropArea.addEventListener('drop', (e) => {
    const dt = e.dataTransfer;
    const files = dt.files;
    const input = document.getElementById('docxInput');
    input.files = files;
    handleFileUpload(input);
  }, false);
});
</script>

</body>
</html>